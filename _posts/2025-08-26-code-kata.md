---
title: "백준2748 - 피보나치 수 2"
date: 2025-08-26 20:15:00 +0900
categories: [Algorithm, DP]
tags: [백준, DP, 코드카타, 알고리즘, 동적계획법, 피보나치]
---

# 백준2748 - 피보나치 수 2

## 문제 정보
- **문제 링크:** [백준 2748번](https://www.acmicpc.net/problem/2748)
- **카테고리:** Dynamic Programming
- **난이도:** Bronze I

## 문제 요약
피보나치 수는 0과 1로 시작하며, 0번째 피보나치 수는 0, 1번째 피보나치 수는 1이다. 그리고 2번째부터는 바로 앞 두 피보나치 수의 합이 된다.

n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.

- **제약 조건:** n ≤ 90

---

## 해결 방법 - Bottom-Up 방식

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class Main {
    static long[] dp = new long[91]; // N≤90이므로 91개로 선언

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine());

        bw.write(String.valueOf(sol(n)));

        br.close();
        bw.close();
    }

    public static long sol(int N) {
        if (N == 0) return 0;
        if (N == 1) return 1;

        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[N];
    }
}
```

## 핵심 아이디어

### DP 상태 정의
`dp[i] = i번째 피보나치 수`

### 점화식
```
dp[i] = dp[i-1] + dp[i-2]
```

### 초기값
- `dp[0] = 0`
- `dp[1] = 1`

## 주의할 점

1. **데이터 타입**: `int` 대신 `long` 사용
   - 피보나치 수는 매우 빠르게 증가 (F(46) > int 최댓값)
   - N≤90 범위에서는 `long`으로 충분

2. **배열 크기**: 정적 배열 `long[91]` 사용
   - N≤90이므로 동적 할당보다 정적 배열이 효율적
   - 메모리 오버헤드 없이 빠른 접근 가능

3. **경계 조건**: N=0, N=1 케이스 별도 처리

4. **반복문 범위**: `i <= N` (N까지 포함)

5. **early return에 대한 고민**: 

```
        if (N == 0) return 0;
        if (N == 1) return 1;
```
이부분은 안넣어도 코드가 정상적으로 실행 됨. 현 범위에선 성능차이가 미미하므로 취향차이

6. **배열 시작지점에 대한 고민**: [백준 9095번](2025-08-25-code-kata.md) 문제는 1부터 의미있는 값이 나타나기 때문에 배열 1번부터 정의하여 코드 작성, 백준 2748번 문제는 0번째 배열의 F(0)=0이라는 의미있는 값이 나오기 때문에 배열 0번부터 정의하여 코드 작성


## 학습 포인트

- **오버플로우 주의**: 문제의 제약 조건을 보고 적절한 데이터 타입 선택
- **메모리 최적화**: 제한된 범위일 때는 정적 배열이 더 효율적
- **기본 DP 패턴**: 피보나치는 가장 기본적인 DP 문제
- **점화식 이해**: 이전 상태들의 관계를 파악하여 점화식 도출

## 시간복잡도
- **시간복잡도**: O(N) - 각 피보나치 수를 한 번씩 계산
- **공간복잡도**: O(N) - DP 배열 크기