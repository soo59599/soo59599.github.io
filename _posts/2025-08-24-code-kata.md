---
title: "백준1463 - 1로 만들기"
date: 2025-08-24 23:17:42 +0900
categories: [Algorithm, DP]
tags: [백준, DP, 코드카타, 알고리즘, 동적계획법]
---

# 백준1463 - 1로 만들기

## 문제 정보
- **문제 링크:** [백준 1463번](https://www.acmicpc.net/problem/1463)
- **카테고리:** Dynamic Programming
- **난이도:** Silver III

## 문제 요약
정수 N이 주어졌을 때, 다음 세 연산을 사용해서 1로 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 구하는 프로그램을 작성하시오.

1. X가 3으로 나누어떨어지면, 3으로 나눈다.
2. X가 2로 나누어떨어지면, 2로 나눈다.  
3. 1을 뺀다.

## 첫 번째 시도 (실패) - Top-Down 방식

```java
package baekjoon;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class Main {
    static int[] dp = new int[1000001];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int num = Integer.parseInt(br.readLine());
        bw.write(sol(num)+"");

        br.close();
        bw.close();
    }

    public static int sol(int num){
        if(num == 1) return 0;
        if(dp[num]!=0) return dp[num];

        dp[num] = sol(num-1)+1;
        
        if(num%2==0){
            dp[num] = Math.min(dp[num], sol(num/2)+1);
        }
        
        if(num%3==0){
            dp[num] = Math.min(dp[num], sol(num/3)+1);
        }

        return dp[num];
    }
}
```

### 결과: 시간초과

**문제점 분석:**
- 탑다운 방식의 재귀 호출로 인한 함수 호출 오버헤드
- 깊은 재귀로 인한 스택 메모리 부담
- 메모이제이션이 있어도 재귀 자체의 비용이 큼

## 해결 방법 - Bottom-Up 방식

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int num = Integer.parseInt(br.readLine());
        bw.write(sol(num) + "");

        br.close();
        bw.close();
    }

    public static int sol(int num) {
        if (num == 1) return 0;
        
        int[] dp = new int[num + 1];
        dp[1] = 0;

        for (int i = 2; i <= num; i++) {
            dp[i] = dp[i - 1] + 1;
            
            if (i % 2 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 2] + 1);
            }
            
            if (i % 3 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 3] + 1);
            }
        }

        return dp[num];
    }
}
```

### 결과: 통과

## 핵심 아이디어

### DP 상태 정의
`dp[i] = 정수 i를 1로 만드는데 필요한 최소 연산 횟수`

### 점화식
```
dp[i] = min(
    dp[i-1] + 1,        // 1을 빼는 경우
    dp[i/2] + 1,        // 2로 나누는 경우 (i가 2의 배수일 때)
    dp[i/3] + 1         // 3으로 나누는 경우 (i가 3의 배수일 때)
)
```

### Top-Down vs Bottom-Up 차이점

| 구분 | Top-Down (재귀) | Bottom-Up (반복) |
|------|----------------|------------------|
| 방식 | 큰 문제 → 작은 문제 | 작은 문제 → 큰 문제 |
| 구현 | 재귀 함수 | 반복문 |
| 메모리 | 스택 메모리 사용 | 배열 메모리만 사용 |
| 속도 | 함수 호출 오버헤드 | 빠름 |

## 학습 포인트
1. **DP 문제에서 시간초과가 나면 Top-Down → Bottom-Up으로 변경 고려**
2. **"역으로 생각하기": N을 만들기 위해 어떤 수에서 왔을까?**
3. **메모이제이션의 중요성**: 같은 계산을 반복하지 않기

## 시간복잡도
- **시간복잡도**: O(N) - 각 수를 한 번씩만 계산
- **공간복잡도**: O(N) - DP 배열 크기